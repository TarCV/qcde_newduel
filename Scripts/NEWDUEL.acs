#library "NEWDUEL"
#include "zcommon.acs"

#libdefine MAXPLAYERS 64
#libdefine MAXMATES 5
#libdefine NUMCHAMPS 20
#libdefine USED -1
#libdefine TICSPERSECOND 35

world int 88:chosenClass[];
world int 87:duelPlayers[];
int champDraftingTime = 15;
bool pressedUse[2];

str champions[NUMCHAMPS] = {
	"Ranger",
	"DoomSlayer",
	"Corvus",
	"Bitterman",
	"Galen",
	"Duke Nukem",
	"Sarge",
	"Grayson",
	"Kane",
	"Caleb",
	"Menelkir",
	"Nyx",
	"Durandal",
	"Lo Wang",
	"Terminator",
	"Zedek",
	"Inquisitor",
	"Sorgaul",
	"Keel",
	"Eradicator"
};
str championFaces[NUMCHAMPS] = {
	"PORTRA01",
	"PORTRA02",
	"PORTRA03",
	"PORTRA10",
	"PORTRA11",
	"PORTRA14",
	"PORTRA17",
	"PORTRA19",
	"PORTRA04",
	"PORTRA05",
	"PORTRA06",
	"PORTRA12",
	"PORTRA15",
	"PORTRA18",
	"PORTRA07",
	"PORTRA08",
	"PORTRA09",
	"PORTRA13",
	"PORTRA16",
	"PORTRA20"
};
str championSprites[NUMCHAMPS] = {
	"QP01A",
	"QP02A",
	"QP03A",
	"QP10A",
	"QP11A",
	"QP14E",
	"QP17A",
	"QP19A",
	"QP04A",
	"QP05A",
	"QP06A",
	"QP12A",
	"QP15A",
	"QP18A",
	"QP07A",
	"QP08A",
	"QP09A",
	"QP13A",
	"QP16A",
	"QP20A"
};
str champ_actions[MAXMATES] = {"+moveleft", "+forward", "+moveright", "+back", "+jump"};
int champ_buttons[MAXMATES] = {BT_MOVELEFT, BT_FORWARD, BT_MOVERIGHT, BT_BACK, BT_JUMP};

int roundActive = 0;
#libdefine ROUND_INIT 0
#libdefine ROUND_PREDRAFT 1
#libdefine ROUND_STARTED 2
#libdefine ROUND_DRAFTING 3
#libdefine ROUND_WARMUP 4
#libdefine ROUND_ILLEGAL_STATE -1

#libdefine ON_OPEN 0
#libdefine ON_PLAYERS_PRESENT 1
#libdefine ON_PLAYERS_DRAFTED 2
#libdefine ON_ROUND_STARTED 3
#libdefine ON_ROUND_FINISHED 4
#libdefine ON_ROUND_ABORTED 5


bool draftReady[2]; 
int whoDraftsNow = -1;
int whoDraftsFirst = 0;
bool updateMatchStatusExecutes = false;

Script "QCDE_Duel_Event"(int type, int arg1, int arg2) Event {
	if (type == 5) { // GAMEEVENT_ROUND_STARTS
		ACS_NamedExecuteWait("QCDED_UpdateMatchStatus", 0, ON_ROUND_STARTED);
	} else if (type == 6) { // ended or aborted
		ACS_NamedExecuteWait("QCDED_UpdateMatchStatus", 0, ON_ROUND_FINISHED);
	} else if (type == 7) {
		ACS_NamedExecuteWait("QCDED_UpdateMatchStatus", 0, ON_ROUND_ABORTED);
	}
}

Script "QCDE_Duel_Use" (int down) Net {
	pressedUse[duelIndex()] = down;
}

Script "QCDED_UpdateMatchStatus" (int when) {
	printbold(s:"QCDED_UpdateMatchStatus started.");
	printbold(s:"state was ", i:roundActive, s:", event was ", i:when); 
/*	int lobbyNum = GetCVar("sv_lobby_mapnum");
	if (lobbyNum >= 0) {
		if (lobbyNum == GetLevelInfo(LEVELINFO_LEVELNUM)) {
			if (when == ON_OPEN) {
				roundActive = ROUND_PREDRAFT;
			}
		} else {
			// Warp to lobby if champions were not drafted
		}
	} else*/ {
		if (roundActive == ROUND_INIT && when == ON_OPEN) {
			roundActive = ROUND_PREDRAFT;
		} else if (roundActive == ROUND_PREDRAFT && when == ON_PLAYERS_PRESENT) {
			roundActive = ROUND_DRAFTING;
		} else if (roundActive == ROUND_DRAFTING && when == ON_PLAYERS_DRAFTED) {
			roundActive = ROUND_WARMUP;
		} else if (when == ON_ROUND_STARTED) {
			if (roundActive != ROUND_WARMUP) {
				PrintBold(s:"Server is set up incorrectly. Please ask the administrator to increase warmup time or decrease drafting time limit.");
			}
			roundActive = ROUND_STARTED;
		} else if (when == ON_ROUND_FINISHED || when == ON_ROUND_ABORTED) {
			roundActive = ROUND_INIT;
		} else if (roundActive == ROUND_WARMUP && when == ON_OPEN) {
			// Intentionally empty. OPEN scripts are executed on round start
		} else if (roundActive == ROUND_STARTED && when == ON_OPEN) {
			// Intentionally empty. OPEN scripts are executed on round start
		} else {
			int oldRound = roundActive;
			roundActive = ROUND_ILLEGAL_STATE;
			while (true) {
				PrintBold(s:"New Duel system crashed. Please send demo to the author. (Tech data: state=",
					i:oldRound, s: ", event=", i:when, s:")");
				delay(35);
			}
		}
	}
	printbold(s:"state became ", i:roundActive, s:", event was ", i:when); 
	printbold(s:"QCDED_UpdateMatchStatus ended");
}

Script "QCDED_World_Loop" (void) {
	printbold(s:"World loop started");
	int lastRound = -1;
	while (true) {
		if (lastRound != roundActive) {
			lastRound = roundActive;
			switch (roundActive) {
				case ROUND_PREDRAFT:
					ACS_NamedExecuteWait("QCDED_WaitForTwoPlayers", 0);
					whoDraftsFirst = Random(0, 1);
					whoDraftsNow = duelPlayers[whoDraftsFirst];
					ACS_NamedExecuteWait("QCDED_UpdateMatchStatus", 0, ON_PLAYERS_PRESENT);
					break;
				case ROUND_DRAFTING:
					ACS_NamedExecuteWait("QCDED_WaitForDraftingCompletion", 0);
					ACS_NamedExecuteWait("QCDED_UpdateMatchStatus", 0, ON_PLAYERS_DRAFTED);
					break;
			}
		}
		delay(17);
	}
	printbold(s:"World loop finished");
}

Script "QCDED_Player_Loop" Enter {
	printbold(s:"Player loop started - ", i:PlayerNumber());
	printbold(i:PlayerNumber(), s:" spect? ", d:PlayerIsSpectator(PlayerNumber()));
	int lastRound = -1;
	bool activated;
	while (PlayerIsSpectator(PlayerNumber()) == 0) {
		if (lastRound != roundActive) {
			lastRound = roundActive;
			switch (roundActive) {
				case ROUND_DRAFTING:
					activated = false;
					neutralizeMe();
					ACS_NamedExecuteAlways("QCDE_Duel_ShowDraft", 0);
					ACS_NamedExecuteAlways("QCDE_Duel_Draft", 0);
					break;
				case ROUND_WARMUP:
				case ROUND_STARTED:
					if (!activated) {
						activated = true;
						activateMe();
					}
					break;
			}
		}
		delay(17);
	}
	printbold(s:"Player loop finished");
}

Script "QCDE_Duel_Open" Open {
	printbold(s:"QCDE_Duel_Open");
	ACS_NamedExecute("QCDED_UpdateMatchStatus", 0, ON_OPEN);
	ACS_NamedExecute("QCDED_World_Loop", 0);
}

Script "QCDED_WaitForTwoPlayers" (void) {
	int cursor;
	while (cursor < 2) {
		cursor = 0;
		for (int i = 0; i < PlayerCount() && cursor < 2; ++i) {
			if (PlayerIsSpectator(PlayerNumber()) == 0) {
				duelPlayers[cursor] = i;
				draftReady[cursor] = false;
				++cursor;
			}
		}
		delay(17);
	}
}

Script "QCDED_WaitForDraftingCompletion" (void) {
printbold(s:"QCDED_WaitForDraftingCompletion start");
	while (!draftReady[0] && !draftReady[1]) {
		delay(17);
	}
	delay(2*TICSPERSECOND); // Give players a chance to see the final selection
printbold(s:"QCDED_WaitForDraftingCompletion end");
}

Script "QCDE_Duel_ShowDraft" (void) {
	if (PlayerIsBot(PlayerNumber())) terminate;
	int yStep = (480 - 250) / MAXMATES;
	int xStep = yStep * 2;
	while (roundActive == ROUND_DRAFTING) {
		for (int i = 0; i < MAXMATES && i < MAXMATES; ++i) {
			int myChampion = getChosenClass(duelIndex(), i);
			int othersChampions = getChosenClass(1 - duelIndex(), i);

			SetHudSize(640, 480, false);

			SetFont("SMALLFONT");
			hudmessage(i:i+1;
				HUDMSG_PLAIN, 0, 0, 300.6, 240.1 + 16.0*i, 7.0 / TICSPERSECOND + 1);
			hudmessage(i:i+1;
				HUDMSG_PLAIN, 0, 0, 340.5, 240.1 + 16.0*i, 7.0 / TICSPERSECOND + 1);
			hudmessage(s:idToClass(myChampion);
				HUDMSG_PLAIN, 0, 0, 280.6, 240.1 + 16.0*i, 7.0 / TICSPERSECOND + 1);
			hudmessage(s:idToClass(othersChampions);
				HUDMSG_PLAIN, 0, 0, 360.5, 240.1 + 16.0*i, 7.0 / TICSPERSECOND + 1);

			if (myChampion >= 0) {
				SetFont(championSprites[myChampion]);
				hudmessage(s:"A";
					HUDMSG_PLAIN, 0, 0, 100.0 + xStep*(i%2)*1.0, 170.2 + yStep*i*1.0, 7.0 / TICSPERSECOND + 1);
			} else if (myChampion < -1) {
				SetFont("BIGFONT");
				hudmessage(i:-myChampion;
					HUDMSG_PLAIN, 0, 0, 100.0 + xStep*(i%2)*1.0, 170.2 + yStep*i*1.0, 7.0 / TICSPERSECOND + 1);
			} 
			if (othersChampions >= 0) {
				SetFont(championSprites[othersChampions]);
				hudmessage(s:"A";
					HUDMSG_PLAIN, 0, 0, 640.0 - 100.0 - xStep*(i%2)*1.0, 170.2 + yStep*i*1.0, 7.0 / TICSPERSECOND + 1);
			} else if (othersChampions < -1) {
				SetFont("BIGFONT");
				hudmessage(i:othersChampions;
					HUDMSG_PLAIN, 0, 0, 640.0 - 100.0 - xStep*(i%2)*1.0, 170.2 + yStep*i*1.0, 7.0 / TICSPERSECOND + 1);
			}
		}
		delay(7);
	}
}

Script "QCDE_Duel_Draft" (void) {
	resetPlayer(duelIndex());

	int forRound = 0;
	while (!draftReady[duelIndex()]) {
		if (whoDraftsNow == PlayerNumber()) {
			if (PlayerIsBot(PlayerNumber())) {
				setChosenClass(duelIndex(), forRound, GetPlayerInfo(PlayerNumber(), PLAYERINFO_PLAYERCLASS));
				// TODO: random class when round > 0
			} else {
				int draftingEnd = timer() + champDraftingTime*TICSPERSECOND;
				int selectedChamp = 0;
				while (findChosen(selectedChamp) != -1) {
					selectedChamp += 1;
				}
				while (true) {
					int buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
					int dir = 0;
					int timeLeft = draftingEnd - timer();
					bool selected = false;
					if (buttons == BT_MOVELEFT || buttons == BT_LEFT) {
						dir = -1;
					} else if (buttons == BT_MOVERIGHT || buttons == BT_RIGHT) {
						dir = 1;
					} else if (timeLeft <= 0 || pressedUse[PlayerNumber()]) {
						selected = true;
						pressedUse[duelIndex()] = 0;
						setChosenClass(duelIndex(), forRound, selectedChamp);
						if (forRound == 0) {
							setNextSpawnClass(selectedChamp);
						}
						break;
					}
					int timeLeftSeconds = timeLeft / TICSPERSECOND;
					if (!selected && timeLeftSeconds > 0) {
						setChosenClass(duelIndex(), forRound, -1 - timeLeftSeconds);
					}

					if (dir) {
						selectedChamp += dir;
						while (findChosen(selectedChamp) != -1) {
							selectedChamp += dir;
						}
					}

					while (selectedChamp < 0) {
						selectedChamp += NUMCHAMPS;
					}
					selectedChamp %= NUMCHAMPS;

					hudmessage(s:"Select - ", s:champions[selectedChamp], s:"?",
						s:" (",  i:timeLeft/TICSPERSECOND, s:" seconds left)";
						HUDMSG_PLAIN, 0, 0, 0.1, 0.9, 7.0 / TICSPERSECOND + 1);
					delay(3);
				}
			}
			if ((whoDraftsFirst + duelIndex() + forRound) % 2 == 0) {
				whoDraftsNow = otherPlayer();
			}
			++forRound;
			if (forRound >= MAXMATES) draftReady[duelIndex()] = true;
		}
		delay(17);
	}
}

Script "QCDE_Duel_Enter" Enter {
	ACS_NamedExecuteAlways("QCDE_Duel_Respawn", 0);
}
Script "QCDE_Duel_Respawn" Respawn {
	if (roundActive != ROUND_STARTED) terminate;

	int class = PlayerClass(PlayerNumber());
	int chosenIndex = findChosen(class);
	if (chosenIndex != -1) {
		setChosenClass(duelIndex(), chosenIndex, USED);
		SetPlayerProperty(0, OFF, PROP_TOTALLYFROZEN);
	} else {
		Print(s:"You didn't select this class");
		neutralizeMe();
	}
}

Script "QCDE_Duel_Death" Death
{
	if (roundActive != ROUND_STARTED) terminate;

	SetHudSize(320, 240, false);
	int canSpawn = 0;
	int champIndex = -1;
	while (GetActorProperty (0, APROP_HEALTH) <= 0) {
		if (canSpawn != 1) {
			// SetPlayerProperty(0, ON, PROP_TOTALLYFROZEN);
			delay(35);
			int class = GetPlayerInfo(PlayerNumber(), PLAYERINFO_PLAYERCLASS);
			Print(s:"My class - ", d:class);
			for (int i = 0; i < MAXMATES; ++i) {
				Print(s:"Possible class (d) - ", d:getChosenClass(duelIndex(), i));
				canSpawn = (class == getChosenClass(duelIndex(), i));
				if (canSpawn)	break;
			}
			Print(s:"IsAllowed class - ", d:canSpawn);
		}

		int index = 0;
		int buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
		for (i = 0; i < MAXMATES; ++i) {
			if (buttons == champ_buttons[i]) {
				champIndex = i;
			}

			class = getChosenClass(duelIndex(), i);
			str selected = "";
			if (i == champIndex) {
				selected = ">";
				setNextSpawnClass(class);
			}
			if (class != USED) {
				hudmessage(s:selected, s:"[", k:champ_actions[index], s:"] - ", s:champions[class];
						HUDMSG_PLAIN, 0, 0, 60.4, 30.1+10.0*index, 7.0 / TICSPERSECOND + 1);
				++index;
			}
		}
		delay(7);
	}
}

Script "QCDE_Duel_Disconnect" (int gone) Disconnect {
	int di = duelIndexFor(gone);
	resetPlayer(di);
	duelPlayers[di] = -1;
}

function void setNextSpawnClass(int class) {
	SetCVarString("qcd_champ", idToClass(class));
	ConsoleCommand("playerclass $qc_duel_champ_selected");
}

function int findChosen(int class) {
	if (class < 0) return -1;
	for (int i = 0; i < MAXMATES; ++i) {
		if (class == getChosenClass(duelIndex(), i)) return i;
	}
	return -1;
}

function void neutralizeMe(void) {
	SetPlayerProperty(0, ON, PROP_TOTALLYFROZEN);
	GiveInventory("GhostWalkInProc", 1);
}
function void activateMe(void) {
	SetPlayerProperty(0, OFF, PROP_TOTALLYFROZEN);
	TakeInventory("GhostWalkInProc", 999);
}

function str idToClass(int id) {
	if (id < 0) {
		return "-";
	}
	return champions[id];
}

function int duelIndex(void) {
	return duelIndexFor(PlayerNumber());
}
function int duelIndexFor(int pn) {
	if (pn == duelPlayers[0]) {
		return 0;
	} else if (pn == duelPlayers[1]) {
		return 1;
	}
	return -1000; // set to a stupid value to catch bugs
}

function int otherPlayer(void) {
	return duelPlayers[1 - duelIndex()];
}

function int getChosenClass(int duelPlayer, int forRound) {
	if (forRound < 0 || forRound >= MAXMATES) {
		return -100;
	}
	if (duelPlayer < 0 || duelPlayer >= 2) {
		return -100;
	}
	return chosenClass[MAXMATES*duelPlayer + forRound];
}

function void setChosenClass(int duelPlayer, int forRound, int newClass) {
	if (forRound < 0 || forRound >= MAXMATES) {
		return;
	}
	if (duelPlayer < 0 || duelPlayer >= 2) {
		return;
	}
	chosenClass[MAXMATES*duelPlayer + forRound] = newClass;
}

function void resetPlayer(int duelPlayer) {
	for (int i = 0; i < MAXMATES; ++i) {
		setChosenClass(duelPlayer, i, USED);
	}
}
